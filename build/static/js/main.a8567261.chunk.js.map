{"version":3,"sources":["features/auth/authSlice.ts","app/App.tsx","serviceWorker.ts","index.tsx","rootReducer.ts","store.ts","features/diary/diariesSlice.ts","features/entry/editorSlice.tsx","features/auth/userSlice.ts","features/entry/entriesSlice.ts"],"names":["auth","createSlice","name","initialState","token","isAuthenticated","reducers","saveToken","state","payload","clearToken","setAuthState","actions","Auth","lazy","Home","App","isLoggedIn","useSelector","path","fallback","type","color","height","width","timeout","className","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","store","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message","rootReducer","combineReducers","authReducer","diaries","diariesReducer","entries","entriesReducer","user","userReducer","editor","editorReducer","configureStore","reducer","useAppDispatch","useDispatch","addDiary","diariesToSave","filter","diary","findIndex","item","id","push","updateDiary","diaryIndex","splice","canEdit","currentlyEditing","activeDiaryId","setCanEdit","setCurrentlyEditing","setActiveDiaryId","setUser","setEntries","updateEntry","index","e"],"mappings":"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","file":"static/js/main.a8567261.chunk.js","sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\n\ninterface AuthState {\n  token: string | null;\n  isAuthenticated: boolean;\n}\n\nconst initialState: AuthState = {\n  token: null,\n  isAuthenticated: false,\n};\n\nconst auth = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    saveToken(state, { payload }: PayloadAction<string>) {\n      if (payload) {\n        state.token = payload;\n      }\n    },\n    clearToken(state) {\n      state.token = null;\n    },\n    setAuthState(state, { payload }: PayloadAction<boolean>) {\n      state.isAuthenticated = payload;\n    },\n  },\n});\n\nexport const { saveToken, clearToken, setAuthState } = auth.actions;\n\nexport default auth.reducer;\n","import React, { FC, lazy, Suspense } from \"react\";\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport { useSelector } from \"react-redux\";\nimport { RootState } from \"../rootReducer\";\nimport \"react-loader-spinner/dist/loader/css/react-spinner-loader.css\";\nimport Loader from \"react-loader-spinner\";\n\nconst Auth = lazy(() => import(\"../features/auth/Auth\"));\nconst Home = lazy(() => import(\"../features/home/Home\"));\n\nconst App: FC = () => {\n  const isLoggedIn = useSelector(\n    (state: RootState) => state.auth.isAuthenticated\n  );\n\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/\">\n          <Suspense\n            fallback={\n              <Loader\n                type=\"ThreeDots\"\n                color=\"#00BFFF\"\n                height={100}\n                width={100}\n                timeout={3000} //3 secs\n                className=\"Loader\"\n              />\n            }\n          >\n            {isLoggedIn ? <Home /> : <Auth />}\n          </Suspense>\n        </Route>\n      </Switch>\n    </Router>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './app/App';\nimport * as serviceWorker from './serviceWorker';\nimport { setupServer } from './services/mirage/server';\nimport { Provider } from 'react-redux';\nimport store from './store';\n\nif (process.env.NODE_ENV === 'development') {\n  setupServer();\n}\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { combineReducers } from '@reduxjs/toolkit';\nimport authReducer from './features/auth/authSlice';\nimport userReducer from './features/auth/userSlice';\nimport diariesReducer from './features/diary/diariesSlice';\nimport entriesReducer from './features/entry/entriesSlice';\nimport editorReducer from './features/entry/editorSlice';\n\nconst rootReducer = combineReducers({\n  auth: authReducer,\n  diaries: diariesReducer,\n  entries: entriesReducer,\n  user: userReducer,\n  editor: editorReducer,\n});\n\nexport type RootState = ReturnType<typeof rootReducer>;\n\nexport default rootReducer;\n","import { configureStore } from '@reduxjs/toolkit';\n\nimport rootReducer from './rootReducer';\nimport { useDispatch } from 'react-redux';\n\nconst store = configureStore({\n  reducer: rootReducer,\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\n\nexport default store;\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { Diary } from '../../interfaces/diary.interface';\n\nconst diaries = createSlice({\n  name: 'diaries',\n  initialState: [] as Diary[],\n  reducers: {\n    addDiary(state, { payload }: PayloadAction<Diary[]>) {\n      const diariesToSave = payload.filter((diary) => {\n        return state.findIndex((item) => item.id === diary.id) === -1;\n      });\n      state.push(...diariesToSave);\n    },\n    updateDiary(state, { payload }: PayloadAction<Diary>) {\n      const { id } = payload;\n      const diaryIndex = state.findIndex((diary) => diary.id === id);\n      if (diaryIndex !== -1) {\n        state.splice(diaryIndex, 1, payload);\n      }\n    },\n  },\n});\n\nexport const { addDiary, updateDiary } = diaries.actions;\n\nexport default diaries.reducer;\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { Entry } from '../../interfaces/entry.interface';\n\ninterface EditorState {\n  canEdit: boolean;\n  currentlyEditing: Entry | null;\n  activeDiaryId: string | null;\n}\n\nconst initialState: EditorState = {\n  canEdit: false,\n  currentlyEditing: null,\n  activeDiaryId: null,\n};\n\nconst editor = createSlice({\n  name: 'editor',\n  initialState,\n  reducers: {\n    setCanEdit(state, { payload }: PayloadAction<boolean>) {\n      state.canEdit = payload != null ? payload : !state.canEdit;\n    },\n    setCurrentlyEditing(state, { payload }: PayloadAction<Entry | null>) {\n      state.currentlyEditing = payload;\n    },\n    setActiveDiaryId(state, { payload }: PayloadAction<string>) {\n      state.activeDiaryId = payload;\n    },\n  },\n});\n\nexport const {\n  setCanEdit,\n  setCurrentlyEditing,\n  setActiveDiaryId,\n} = editor.actions;\n\nexport default editor.reducer;\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { User } from '../../interfaces/user.interface';\n\nconst user = createSlice({\n  name: 'user',\n  initialState: null as User | null,\n  reducers: {\n    setUser(state, { payload }: PayloadAction<User>) {\n      return (state = payload);\n    },\n  },\n});\n\nexport const { setUser } = user.actions;\n\nexport default user.reducer;\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { Entry } from '../../interfaces/entry.interface';\n\nconst entries = createSlice({\n  name: 'entries',\n  initialState: [] as Entry[],\n  reducers: {\n    setEntries(state, { payload }: PayloadAction<Entry[] | null>) {\n      return (state = payload != null ? payload : []);\n    },\n    updateEntry(state, { payload }: PayloadAction<Entry>) {\n      const { id } = payload;\n      const index = state.findIndex((e) => e.id === id);\n      if (index !== -1) {\n        state.splice(index, 1, payload);\n      }\n    },\n  },\n});\n\nexport const { setEntries, updateEntry } = entries.actions;\n\nexport default entries.reducer;\n"],"sourceRoot":""}